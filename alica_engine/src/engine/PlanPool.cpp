#include "engine/PlanPool.h"
#include "engine/AlicaEngine.h"
#include "engine/BasicPlan.h"
#include "engine/IPlanCreator.h"
#include "engine/PlanRepository.h"
#include "engine/RunningPlan.h"
#include "engine/model/Plan.h"
#include "engine/model/ConfAbstractPlanWrapper.h"
#include "engine/model/Configuration.h"

//#define ALICA_DEBUG_LEVEL_ALL
#include <alica_common_config/debug_output.h>

namespace alica
{

/**
 * Basic Constructor.
 */
PlanPool::PlanPool(AlicaEngine* ae)
        : _ae(ae)

{
}

/**
 * Basic Destructor.
 */
PlanPool::~PlanPool() = default;

/**
 * Creates instances of BasicPlan, needed according to the PlanRepository, with the help of the given
 * PlanCreator. If a BasicPlan cannot be instantiated, the Initialisation of the Pool is cancelled.
 * @param planCreator A PlanCreator.
 * @return True, if all necessary BasicPlan could be constructed. False, if the Initialisation was cancelled.
 */
bool PlanPool::init(IPlanCreator& planCreator)
{
    const PlanRepository::Accessor<ConfAbstractPlanWrapper>& wrappers = _ae->getPlanRepository().getConfAbstractPlanWrappers();
    for (const ConfAbstractPlanWrapper* wrapper : wrappers) {
        if (const auto* plan = dynamic_cast<const Plan*>(wrapper->getAbstractPlan())) {
            if (getBasicPlan(plan, wrapper->getConfiguration())) {
                // A BasicPlan representing this combination of Plan and Configuration was created already!
                continue;
            }

            auto basicPlan = planCreator.createPlan(plan->getId());
            if (!basicPlan) {
                // probably something with the (autogenerated) plan creator is wrong
                return false;
            }

            // set stuff from plan and configuration in basic plan object
            basicPlan->setConfiguration(wrapper->getConfiguration());
            basicPlan->setName(plan->getName());
            if (plan->getFrequency() < 1) {
                basicPlan->setInterval(0);
            } else {
                basicPlan->setInterval(1000 / plan->getFrequency());
            }
            basicPlan->setEngine(_ae);
            _availablePlans.insert(std::make_pair(wrapper, std::move(basicPlan)));
        }
    }
    return true;
}

/**
 * Enables the thread of the BasicPlan in the given RunningPlan.
 * @param rp A RunningPlan, which should represent a PlanConfiguration.
 */
void PlanPool::startPlan(RunningPlan& rp)
{
    if (const auto* plan = dynamic_cast<const Plan*>(rp.getActivePlan())) {
        if (auto basicPlan = getBasicPlan(plan, rp.getConfiguration())) {
            // set both directions rp <-> basicPlan
            rp.setBasicPlan(basicPlan);
            basicPlan->start(&rp);
            return;
        }
    }

    ALICA_ERROR_MSG("PP::startPlan(): Cannot start Plan of given RunningPlan! Plan Name: " << rp.getActivePlan()->getName()
                                                                                                     << " Plan Id: " << rp.getActivePlan()->getId());
}

/**
 * Disables the thread of the BasicPlan in the given RunningPlan.
 * @param rp A RunningPlan, which should represent a PlanConfiguration.
 */
void PlanPool::stopPlan(RunningPlan& rp)
{
   if (const auto* plan = dynamic_cast<const Plan*>(rp.getActivePlan())) {
       if (auto basicPlan = getBasicPlan(plan, rp.getConfiguration())) {
           basicPlan->stop();
       }
   } else {
       ALICA_ERROR_MSG("PP::stopPlan(): Cannot stop Plan of given RunningPlan! Plan Name: " << rp.getActivePlan()->getName()
                                                                                                      << " Plan Id: " << rp.getActivePlan()->getId());
   }
}

/**
 * Calls stop on all BasicPlans.
 */
void PlanPool::stopAll()
{
    for (auto& plan_pair : _availablePlans) {
        plan_pair.second->stop();
    }
}

BasicPlan* PlanPool::getBasicPlan(const Plan* plan, const Configuration* configuration) const
{
    for (const auto& poolEntry : _availablePlans) {
        if (poolEntry.first->getAbstractPlan() == plan && poolEntry.first->getConfiguration() == configuration) {
            return poolEntry.second.get();
        }
    }
    return nullptr;
}

} /* namespace alica */
