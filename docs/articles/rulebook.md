# Rulebook

The Control Layer is the most complex layer of the runtime engine because its function is to control the progress of the agent in its ALICA program while coordinating with other teammates. The central module is the Plan Base module. It holds the runtime representation of the ALICA program, including information about which agent is currently occupying which state in the plan tree structure. The Plan Base also controls that the other modules have access to the runtime representation of the ALICA program in the right order. The Behaviour Pool module is similar to a thread pool, including one thread per behaviour. The Plan Base commands the Behaviour Pool to start or stop certain behaviours according to the execution state of the agent in the ALICA program. When a behaviour succeeds or fails, it sends a signal back to the Plan Base accordingly. The Sync Module is responsible for coordinating the passing of [synchronised transitions](./synchronisations.md).

The Rule Book module is the central part of the operational semantics of the ALICA runtime engine. Given a runtime representation of a plan of the ALICA program, the Rule Book module decides about the next step in this plan, according to its rules and the priorities among the rules. The following paragraphs list the rules with decreasing priority and give a summary of the meaning of each rule.

**Init** The Init rule is triggered if the agent is starting to execute an ALICA program or if the runtime representation of the ALICA program is empty, due to failed plan execution. As a result, the agent is believed to occupy the initial state of the top-level plan, and it is deemed necessary to trigger the task allocation for the initial state.
**RoleAlloc** In case the team composition changes, because agents join, leave, or change their capabilities, the RoleAlloc rule triggers the reallocation of roles to the team.
**BSuccess** Every successful execution of a behaviour triggers the BSuccess rule. The rule stops the execution of the behaviour and asserts the postcondition of the behaviour. 
**TSuccess** The TSuccess rule handles the successful execution of a task by the local agent. Therefore, the successful execution is memorised in the Plan Base module and communicated to all other team members, because the successful execution, informally speaking, reduces the minimum cardinality of the task by one, as long as the plan is not restarted or stopped. Primarily, this influences the [task allocation](./task_allocation.md) of each the agent and makes it possible for the agent to get assigned to another task of the same plan.
**STrans** In case the Sync Module established a mutual belief to pass a synchronised transition, the STrans rule applies the transition over the synchronised transition by stopping the execution of every plan, plantype, or behaviour in the current state, moving the agent and its teammates to the state over the transition and demands a task allocation in this new state.
**Trans** The Trans rule is similar to the STrans rule, but it does not require to establish a mutual belief with other teammates. Only the precondition of the transition needs to hold, and other agents, that also occupied the former state are expected to move along the transition, too. This assumption reduces asynchronous runtime representations of the ALICA program within the team, because the runtime engine makes optimistic assumptions about the progress of other teammates, instead of relying on potentially delayed communication.
**Alloc** Whenever it is deemed necessary to make an initial task allocation within the context of state, e. g., because an agent just entered the state by following a transition, the Alloc rule starts the Task Allocation module, in order to recursively assign tasks with the state and all reachable child plans.
**Adapt** A crucial role for a task allocation is its utility according to the current situation. The Adapt rule recurrently revaluates the utility of all task allocations and triggers a new task allocation, if the agent believes that another allocation is of higher utility.

Apart from the RoleAlloc rule, all rules described so far are denoted as operational rules, have higher precedence than the following rules, and are sufficient for the execution of an ALICA program. The following rules and the RoleAlloc rule are denoted as repair rules. As the name implies, the repair rules handle faulty execution of plans, behaviours, and task allocations. To some extent, the repair rules are domain-dependent, because restarting a behaviour to grasp some object when it already broke by falling to the floor, e. g., is not the best strategy. 

The general repair strategy implemented in the ALICA runtime engine is to restart the behaviour, plan, or task allocation up to a configurable number of retries and, in case it was not possible to repair runtime representation on the current plan level, to propagate the failure up the plan hierarchy. 

The BAbort rule aborts the execution of behaviours if the behaviour signals that it failed. As a result, the fail counter of the behaviour is increased, and the BRedo rule restarts the execution of the behaviour. If the fail counter reaches its threshold, the BProp rule propagates the failure to the context the behaviour is running, i. e. the fail counter of the plan that includes the behaviour is increased by one. For behaviours, these three rules are simple, because behaviours are atomic from the perspective of the engine and therefore can either be executed or stopped. 

In case of plans, the corresponding rules PAbort, PRedo, and PProp are more complex, and the rules PReplace and PTopFail handle other exceptional cases. The PAbort rule stops the execution of the plan and all behaviours, plans, and plantypes running in the current state of the plan. Further, it increases the plans fail counter waiting for other rules to react. While the PAbort rule handles all kind of failures, e. g., failed preconditions, failed runtime conditions, task allocations not fulfilling some tasks minimum cardinalities, the PRedo rule is only triggered if the agents reach a failure state for the first time and all other requirements for the execution of the plan are still met. The PRedo rule simply restarts the execution of the task the agent was working on before and increases the plans fail counter by one. If the fail counter is not zero, the PRedo rule is not applied.

With regard to the propagation of failures, PProp and PReplace offer two different options. The PReplace rule triggers the calculation of a new task allocation within the context of the state the failed plan is running in. The PProp increases the fail counter of the parent plan and aborts it as PAbort would do for the parent plan. In case the fail propagation reaches the top-level plan, the PTopFail rule is triggered and simply calls the Init rule for the top-level plan. The NExpand rule handles the case when a valid task allocation is not possible to find. Therefore, the rule increases the fail count of the plan.

The order of precedence for the repair rules is chosen with regard to their effort to repair the plans and behaviours, starting with the least amount of effort: BAbort, BRedo, BProp, PTopFail, PRedo, PAbort, PReplace, PProp, NExpand.

**NAV** *prev: [Domain-Independence](domain-independence.md)*  *top: [Overview](../README.md)*

